package k8s

import (
	"time"

	"k8s.io/apimachinery/pkg/runtime/schema"
)

// DummyRepository provides fake data for prototyping
type DummyRepository struct{}

func NewDummyRepository() *DummyRepository {
	return &DummyRepository{}
}

func (r *DummyRepository) GetPods() ([]Pod, error) {
	now := time.Now()
	return []Pod{
		{
			ResourceMetadata: ResourceMetadata{
				Namespace: "default",
				Name:      "nginx-deployment-7d64f8d9c8-abc12",
				Age:       24 * time.Hour,
				CreatedAt: now.Add(-24 * time.Hour),
			},
			Ready:    "1/1",
			Status:   "Running",
			Restarts: 0,
			Node:     "node-1",
			IP:       "10.244.1.5",
		},
		{
			ResourceMetadata: ResourceMetadata{
				Namespace: "default",
				Name:      "nginx-deployment-7d64f8d9c8-def34",
				Age:       24 * time.Hour,
				CreatedAt: now.Add(-24 * time.Hour),
			},
			Ready:    "1/1",
			Status:   "Running",
			Restarts: 2,
			Node:     "node-2",
			IP:       "10.244.2.3",
		},
		{
			ResourceMetadata: ResourceMetadata{
				Namespace: "kube-system",
				Name:      "coredns-5d78c9869d-xyz89",
				Age:       168 * time.Hour,
				CreatedAt: now.Add(-168 * time.Hour),
			},
			Ready:    "1/1",
			Status:   "Running",
			Restarts: 0,
			Node:     "node-1",
			IP:       "10.244.1.2",
		},
		{
			ResourceMetadata: ResourceMetadata{
				Namespace: "production",
				Name:      "api-server-6b9f8c7d5e-qwert",
				Age:       2 * time.Hour,
				CreatedAt: now.Add(-2 * time.Hour),
			},
			Ready:    "0/1",
			Status:   "CrashLoopBackOff",
			Restarts: 15,
			Node:     "node-3",
			IP:       "10.244.3.7",
		},
	}, nil
}

func (r *DummyRepository) GetDeployments() ([]Deployment, error) {
	now := time.Now()
	return []Deployment{
		{
			ResourceMetadata: ResourceMetadata{
				Namespace: "default",
				Name:      "nginx-deployment",
				Age:       24 * time.Hour,
				CreatedAt: now.Add(-24 * time.Hour),
			},
			Ready:     "2/2",
			UpToDate:  2,
			Available: 2,
		},
		{
			ResourceMetadata: ResourceMetadata{
				Namespace: "kube-system",
				Name:      "coredns",
				Age:       168 * time.Hour,
				CreatedAt: now.Add(-168 * time.Hour),
			},
			Ready:     "2/2",
			UpToDate:  2,
			Available: 2,
		},
		{
			ResourceMetadata: ResourceMetadata{
				Namespace: "production",
				Name:      "api-server",
				Age:       48 * time.Hour,
				CreatedAt: now.Add(-48 * time.Hour),
			},
			Ready:     "1/3",
			UpToDate:  1,
			Available: 1,
		},
	}, nil
}

func (r *DummyRepository) GetServices() ([]Service, error) {
	now := time.Now()
	return []Service{
		{
			ResourceMetadata: ResourceMetadata{
				Namespace: "default",
				Name:      "kubernetes",
				Age:       168 * time.Hour,
				CreatedAt: now.Add(-168 * time.Hour),
			},
			Type:       "ClusterIP",
			ClusterIP:  "10.96.0.1",
			ExternalIP: "<none>",
			Ports:      "443/TCP",
		},
		{
			ResourceMetadata: ResourceMetadata{
				Namespace: "default",
				Name:      "nginx-service",
				Age:       24 * time.Hour,
				CreatedAt: now.Add(-24 * time.Hour),
			},
			Type:       "LoadBalancer",
			ClusterIP:  "10.96.10.5",
			ExternalIP: "203.0.113.45",
			Ports:      "80/TCP,443/TCP",
		},
		{
			ResourceMetadata: ResourceMetadata{
				Namespace: "production",
				Name:      "api-service",
				Age:       48 * time.Hour,
				CreatedAt: now.Add(-48 * time.Hour),
			},
			Type:       "ClusterIP",
			ClusterIP:  "10.96.20.10",
			ExternalIP: "<none>",
			Ports:      "8080/TCP",
		},
	}, nil
}

func (r *DummyRepository) GetPodsForDeployment(namespace, name string) ([]Pod, error) {
	// Get all pods
	allPods, err := r.GetPods()
	if err != nil {
		return nil, err
	}

	// Filter pods by deployment name (simplified: match pod name prefix)
	filteredPods := make([]Pod, 0)
	for _, pod := range allPods {
		// Match by namespace and pod name containing deployment name
		if pod.Namespace == namespace {
			// Simple heuristic: pod names generated by deployments start with deployment name
			// e.g., nginx-deployment-7d64f8d9c8-abc12 matches nginx-deployment
			if len(pod.Name) > len(name) && pod.Name[:len(name)] == name {
				filteredPods = append(filteredPods, pod)
			}
		}
	}

	return filteredPods, nil
}

func (r *DummyRepository) GetPodsOnNode(nodeName string) ([]Pod, error) {
	// Get all pods
	allPods, err := r.GetPods()
	if err != nil {
		return nil, err
	}

	// Filter pods by node name
	filteredPods := make([]Pod, 0)
	for _, pod := range allPods {
		if pod.Node == nodeName {
			filteredPods = append(filteredPods, pod)
		}
	}

	return filteredPods, nil
}

func (r *DummyRepository) GetPodsForService(namespace, name string) ([]Pod, error) {
	// Get all pods
	allPods, err := r.GetPods()
	if err != nil {
		return nil, err
	}

	// Filter pods by service name (simplified: match pod name prefix)
	filteredPods := make([]Pod, 0)
	for _, pod := range allPods {
		if pod.Namespace == namespace {
			// Simple heuristic: match pods by removing "-service" suffix from service name
			servicePrefixName := name
			if len(name) > 8 && name[len(name)-8:] == "-service" {
				servicePrefixName = name[:len(name)-8]
			}
			// Match pod names that start with the service prefix
			if len(pod.Name) > len(servicePrefixName) && pod.Name[:len(servicePrefixName)] == servicePrefixName {
				filteredPods = append(filteredPods, pod)
			}
		}
	}

	return filteredPods, nil
}

func (r *DummyRepository) GetPodsForStatefulSet(namespace, name string) ([]Pod, error) {
	// Get all pods
	allPods, err := r.GetPods()
	if err != nil {
		return nil, err
	}

	// Filter pods by statefulset name (simplified: match pod name prefix)
	filteredPods := make([]Pod, 0)
	for _, pod := range allPods {
		if pod.Namespace == namespace {
			// Simple heuristic: pod names generated by statefulsets start with statefulset name
			// e.g., web-0, web-1 matches statefulset "web"
			if len(pod.Name) > len(name) && pod.Name[:len(name)] == name {
				filteredPods = append(filteredPods, pod)
			}
		}
	}

	return filteredPods, nil
}

func (r *DummyRepository) GetPodsForDaemonSet(namespace, name string) ([]Pod, error) {
	// Get all pods
	allPods, err := r.GetPods()
	if err != nil {
		return nil, err
	}

	// Filter pods by daemonset name (simplified: match pod name prefix)
	filteredPods := make([]Pod, 0)
	for _, pod := range allPods {
		if pod.Namespace == namespace {
			// Simple heuristic: pod names generated by daemonsets start with daemonset name
			// e.g., fluentd-abc12 matches daemonset "fluentd"
			if len(pod.Name) > len(name) && pod.Name[:len(name)] == name {
				filteredPods = append(filteredPods, pod)
			}
		}
	}

	return filteredPods, nil
}

func (r *DummyRepository) GetPodsForJob(namespace, name string) ([]Pod, error) {
	// Get all pods
	allPods, err := r.GetPods()
	if err != nil {
		return nil, err
	}

	// Filter pods by job name (simplified: match pod name prefix)
	filteredPods := make([]Pod, 0)
	for _, pod := range allPods {
		if pod.Namespace == namespace {
			// Simple heuristic: pod names generated by jobs start with job name
			// e.g., backup-job-abc12 matches job "backup-job"
			if len(pod.Name) > len(name) && pod.Name[:len(name)] == name {
				filteredPods = append(filteredPods, pod)
			}
		}
	}

	return filteredPods, nil
}

func (r *DummyRepository) GetJobsForCronJob(namespace, name string) ([]Job, error) {
	// Return dummy jobs for testing
	return []Job{
		{
			ResourceMetadata: ResourceMetadata{
				Namespace: namespace,
				Name:      name + "-27893456",
				Age:       2 * time.Hour,
				CreatedAt: time.Now().Add(-2 * time.Hour),
			},
			Completions: "1/1",
			Duration:    15 * time.Second,
		},
		{
			ResourceMetadata: ResourceMetadata{
				Namespace: namespace,
				Name:      name + "-27893450",
				Age:       26 * time.Hour,
				CreatedAt: time.Now().Add(-26 * time.Hour),
			},
			Completions: "1/1",
			Duration:    20 * time.Second,
		},
	}, nil
}

func (r *DummyRepository) GetPodsForNamespace(namespace string) ([]Pod, error) {
	// Get all pods
	allPods, err := r.GetPods()
	if err != nil {
		return nil, err
	}

	// Filter pods by namespace
	filteredPods := make([]Pod, 0)
	for _, pod := range allPods {
		if pod.Namespace == namespace {
			filteredPods = append(filteredPods, pod)
		}
	}

	return filteredPods, nil
}

func (r *DummyRepository) GetPodsUsingConfigMap(namespace, name string) ([]Pod, error) {
	// Get all pods
	allPods, err := r.GetPods()
	if err != nil {
		return nil, err
	}

	// Return a subset for testing (simplified: return first pod in namespace)
	filteredPods := make([]Pod, 0)
	for _, pod := range allPods {
		if pod.Namespace == namespace {
			filteredPods = append(filteredPods, pod)
			break // Just return one for testing
		}
	}

	return filteredPods, nil
}

func (r *DummyRepository) GetPodsUsingSecret(namespace, name string) ([]Pod, error) {
	// Get all pods
	allPods, err := r.GetPods()
	if err != nil {
		return nil, err
	}

	// Return a subset for testing (simplified: return first pod in namespace)
	filteredPods := make([]Pod, 0)
	for _, pod := range allPods {
		if pod.Namespace == namespace {
			filteredPods = append(filteredPods, pod)
			break // Just return one for testing
		}
	}

	return filteredPods, nil
}

func (r *DummyRepository) GetPodsForReplicaSet(namespace, name string) ([]Pod, error) {
	// Return dummy pods
	return []Pod{
		{
			ResourceMetadata: ResourceMetadata{
				Namespace: namespace,
				Name:      "nginx-abc123-xyz789",
				Age:       5 * time.Hour,
				CreatedAt: time.Now().Add(-5 * time.Hour),
			},
			Status:   "Running",
			Ready:    "1/1",
			Restarts: 0,
		},
	}, nil
}

func (r *DummyRepository) GetReplicaSetsForDeployment(namespace, name string) ([]ReplicaSet, error) {
	// Return dummy ReplicaSets
	return []ReplicaSet{
		{
			ResourceMetadata: ResourceMetadata{
				Namespace: namespace,
				Name:      name + "-abc123",
				Age:       10 * time.Hour,
				CreatedAt: time.Now().Add(-10 * time.Hour),
			},
			Desired: 3,
			Current: 3,
			Ready:   3,
		},
	}, nil
}

func (r *DummyRepository) GetPodsForPVC(namespace, name string) ([]Pod, error) {
	// Return dummy pods
	return []Pod{
		{
			ResourceMetadata: ResourceMetadata{
				Namespace: namespace,
				Name:      "app-xyz789",
				Age:       3 * time.Hour,
				CreatedAt: time.Now().Add(-3 * time.Hour),
			},
			Status:   "Running",
			Ready:    "1/1",
			Restarts: 0,
		},
	}, nil
}

func (r *DummyRepository) GetResourceYAML(gvr schema.GroupVersionResource, namespace, name string) (string, error) {
	// Return dummy YAML for development
	return `apiVersion: v1
kind: Pod
metadata:
  name: ` + name + `
  namespace: ` + namespace + `
status:
  phase: Running`, nil
}

func (r *DummyRepository) DescribeResource(gvr schema.GroupVersionResource, namespace, name string) (string, error) {
	// Return dummy describe output for development
	return `Name:         ` + name + `
Namespace:    ` + namespace + `
Status:       Running
(Dummy data - connect to real cluster for actual describe output)`, nil
}

func (r *DummyRepository) Close() {
	// No-op for dummy repository
}

func (r *DummyRepository) GetKubeconfig() string {
	return ""
}

func (r *DummyRepository) GetContext() string {
	return ""
}

func (r *DummyRepository) GetResources(resourceType ResourceType) ([]any, error) {
	switch resourceType {
	case ResourceTypePod:
		pods, err := r.GetPods()
		if err != nil {
			return nil, err
		}
		result := make([]any, len(pods))
		for i, p := range pods {
			result[i] = p
		}
		return result, nil
	case ResourceTypeDeployment:
		deployments, err := r.GetDeployments()
		if err != nil {
			return nil, err
		}
		result := make([]any, len(deployments))
		for i, d := range deployments {
			result[i] = d
		}
		return result, nil
	case ResourceTypeService:
		services, err := r.GetServices()
		if err != nil {
			return nil, err
		}
		result := make([]any, len(services))
		for i, s := range services {
			result[i] = s
		}
		return result, nil
	default:
		return []any{}, nil
	}
}

func (r *DummyRepository) GetResourceStats() []ResourceStats {
	now := time.Now()
	return []ResourceStats{
		{
			ResourceType: ResourceTypePod,
			Count:        4,
			LastUpdate:   now.Add(-5 * time.Second),
			AddEvents:    10,
			UpdateEvents: 50,
			DeleteEvents: 3,
			Synced:       true,
			MemoryBytes:  4096, // ~4KB (4 pods * 1KB)
		},
		{
			ResourceType: ResourceTypeDeployment,
			Count:        3,
			LastUpdate:   now.Add(-2 * time.Second),
			AddEvents:    5,
			UpdateEvents: 12,
			DeleteEvents: 1,
			Synced:       true,
			MemoryBytes:  3072, // ~3KB
		},
		{
			ResourceType: ResourceTypeService,
			Count:        3,
			LastUpdate:   now.Add(-10 * time.Second),
			AddEvents:    3,
			UpdateEvents: 8,
			DeleteEvents: 0,
			Synced:       true,
			MemoryBytes:  3072, // ~3KB
		},
		{
			ResourceType: ResourceTypeConfigMap,
			Count:        5,
			LastUpdate:   now.Add(-1 * time.Minute),
			AddEvents:    5,
			UpdateEvents: 2,
			DeleteEvents: 0,
			Synced:       true,
			MemoryBytes:  5120, // ~5KB
		},
		{
			ResourceType: ResourceTypeSecret,
			Count:        8,
			LastUpdate:   now.Add(-30 * time.Second),
			AddEvents:    8,
			UpdateEvents: 5,
			DeleteEvents: 2,
			Synced:       true,
			MemoryBytes:  8192, // ~8KB
		},
		{
			ResourceType: ResourceTypeNamespace,
			Count:        5,
			LastUpdate:   now.Add(-5 * time.Minute),
			AddEvents:    5,
			UpdateEvents: 0,
			DeleteEvents: 0,
			Synced:       true,
			MemoryBytes:  5120, // ~5KB
		},
		{
			ResourceType: ResourceTypeStatefulSet,
			Count:        2,
			LastUpdate:   now.Add(-1 * time.Hour),
			AddEvents:    2,
			UpdateEvents: 10,
			DeleteEvents: 0,
			Synced:       true,
			MemoryBytes:  2048, // ~2KB
		},
		{
			ResourceType: ResourceTypeDaemonSet,
			Count:        3,
			LastUpdate:   now.Add(-2 * time.Hour),
			AddEvents:    3,
			UpdateEvents: 15,
			DeleteEvents: 0,
			Synced:       true,
			MemoryBytes:  3072, // ~3KB
		},
		{
			ResourceType: ResourceTypeJob,
			Count:        10,
			LastUpdate:   now.Add(-15 * time.Second),
			AddEvents:    25,
			UpdateEvents: 30,
			DeleteEvents: 15,
			Synced:       true,
			MemoryBytes:  10240, // ~10KB
		},
		{
			ResourceType: ResourceTypeCronJob,
			Count:        4,
			LastUpdate:   now.Add(-1 * time.Minute),
			AddEvents:    4,
			UpdateEvents: 8,
			DeleteEvents: 0,
			Synced:       true,
			MemoryBytes:  4096, // ~4KB
		},
		{
			ResourceType: ResourceTypeNode,
			Count:        3,
			LastUpdate:   now.Add(-5 * time.Hour),
			AddEvents:    3,
			UpdateEvents: 20,
			DeleteEvents: 0,
			Synced:       true,
			MemoryBytes:  3072, // ~3KB
		},
	}
}

// Context management methods (stub implementations for testing)

func (r *DummyRepository) SwitchContext(contextName string, progress chan<- ContextLoadProgress) error {
	return nil // Stub for testing
}

func (r *DummyRepository) GetAllContexts() []ContextWithStatus {
	return []ContextWithStatus{} // Stub for testing
}

func (r *DummyRepository) GetActiveContext() string {
	return "dummy-context" // Stub for testing
}

func (r *DummyRepository) RetryFailedContext(contextName string, progress chan<- ContextLoadProgress) error {
	return nil // Stub for testing
}

func (r *DummyRepository) GetContexts() ([]Context, error) {
	// Return dummy contexts for testing
	return []Context{
		{
			Name:      "dummy-context",
			Cluster:   "dummy-cluster",
			User:      "dummy-user",
			Namespace: "default",
			Status:    "Loaded",
			Current:   "✓",
			Error:     "",
		},
	}, nil
}

// EnsureCRInformer stub for testing (dummy repository doesn't support dynamic CRs)
func (r *DummyRepository) IsInformerSynced(gvr schema.GroupVersionResource) bool {
	return true // Dummy always returns true (no actual informer)
}

func (r *DummyRepository) AreTypedInformersReady() bool {
	return true // Dummy always returns true (no actual informers)
}

func (r *DummyRepository) GetTypedInformersSyncError() error {
	return nil // Dummy never fails
}

func (r *DummyRepository) GetDynamicInformerSyncError(gvr schema.GroupVersionResource) error {
	return nil // Dummy never fails
}

func (r *DummyRepository) EnsureCRInformer(gvr schema.GroupVersionResource) error {
	return nil // Stub for testing
}

func (r *DummyRepository) EnsureResourceTypeInformer(resourceType ResourceType) error {
	return nil // Stub for testing
}

// GetResourcesByGVR stub for testing (dummy repository doesn't support dynamic CRs)
func (r *DummyRepository) GetResourcesByGVR(gvr schema.GroupVersionResource, transform TransformFunc) ([]any, error) {
	return []any{}, nil // Return empty list for testing
}
